/**
* Payrobot
* # Introduction Accept, store, send or forward Bitcoin, Litecoin and Bitcoin Cash for your website or app and protect your privacy.  Supported crytocurrencies:   * BTC Bitcoin   * LTC Litecoin   * BCH Bitcoin Cash   ## Benefits    * **Anonymous** No personal details are required and transactions are mixed among all payments. You can forward your payments so as soon payrobot.io receives it forwards it to another address under your control.      * **No Registration** No registration, sign-up, application or form required to use payrobot.io      * **Easy Integration** Integrate your web / app through our simple RESTful API, you can accept payments with just one line of code!      * **Instant Payment Notification** Our servers notify your web / app the status of your payments. No polling, daemons or cronjobs required on your side!      * **Secure** Payrobot.io works with SSL and bank-level security protocols. Your transactions are safe!   ## Features **Payment Forward** Generate one-time addresses to recieve payments. Payrobot will notify your web /app through callbacks (webhooks) the status of the payment. As soon as it's confirmed the payment is forwarded to your desired address.  **Wallet** Receive, send payments and store your coins in a secure, private and anonymous wallet. All events are notified to your web / app through callbacks (webhooks). You can generate wallets with just one line of code without registration or further information  ## Fees **Only 0.90% per inbound transaction** (receive payments), NO HIDDEN FEES. All outbound transactions (send funds) are totally free.  Minimum fees applies, therefore the largest amount is going to be considered as fee either: `(inboundAmount*feePct)` or `the minimum fee`  **Inbound Fees (Receive payments)**    - `Bitcoin` 0.90% *(Minimum fee 0.00005 BTC)*   - `Litecoin` 0.90% *(Minimum fee 0.0005 LTC)*   - `Bitcoin Cash` 0.90% *(Minimum fee 0.0005 BCH)*     **Outbound Fees (Send funds)**    - `Bitcoin` 0.00%   - `Litecoin` 0.00%   - `Bitcoin Cash` 0.00%   ## Rate Limit To guarantee the good performance of the service and its fair use. The API is **limited to receiving 120 requests per minute per IP**, which is sufficient for most use cases.  Payrobot.io is asynchronous in most API methods to communicate with your application through callbacks (webhooks), thus reducing unnecessary calls to the service.  **If the limit is exceeded, the IP will be banned for 1 minute.**  If you require an upper limit for your application, do not hesitate to contact us  ## Considerations    * Amounts in responses are expresed as `strings`      * Wallets are not multi-currency, you have to create a different wallet per cryptocurrency (You can't store Litecoin in a Bitcoin wallet and vice-versa)      * Payment forwarding has to be of the same type of currency (You can't forward a Bitcoin Cash payment to a Bitcoin address and vice-versa)    
*
* The version of the OpenAPI document: 1.0
* Contact: contact@payrobot.io
*
* NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
* https://openapi-generator.tech
* Do not edit the class manually.
*/
package payrobot.apis

import payrobot.models.ErrorResponse
import payrobot.models.Wallet
import payrobot.models.WalletCreationInfo
import payrobot.models.WalletHistory
import payrobot.models.WalletSendRequest

import payrobot.infrastructure.ApiClient
import payrobot.infrastructure.ClientException
import payrobot.infrastructure.ClientError
import payrobot.infrastructure.ServerException
import payrobot.infrastructure.ServerError
import payrobot.infrastructure.MultiValueMap
import payrobot.infrastructure.RequestConfig
import payrobot.infrastructure.RequestMethod
import payrobot.infrastructure.ResponseType
import payrobot.infrastructure.Success
import payrobot.infrastructure.toMultiValue

class WalletApi(basePath: kotlin.String = defaultBasePath) : ApiClient(basePath) {
    companion object {
        @JvmStatic
        val defaultBasePath: String by lazy {
            System.getProperties().getProperty("payrobot.baseUrl", "https://api.payrobot.io")
        }
    }

    /**
    * Create new wallet
    * Creates a new wallet where you can receive, store and send funds for your web or app.  --- ## Important This method returns your &#x60;Wallet Passphrase&#x60;, it will be required when you send funds from your wallet. **Please keep it safe and private** 
    * @param currency Object Currency:   * &#x60;btc&#x60;: Bitcoin   * &#x60;ltc&#x60;: Litecoin   * &#x60;bch&#x60;: Bitcoin Cash  
    * @return WalletCreationInfo
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun createWallet(currency: kotlin.String) : WalletCreationInfo {
        val localVariableBody: kotlin.Any? = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        val localVariableConfig = RequestConfig(
            RequestMethod.POST,
            "/{currency}/wallets".replace("{"+"currency"+"}", "$currency"),
            query = localVariableQuery,
            headers = localVariableHeaders
        )
        val localVarResponse = request<WalletCreationInfo>(
            localVariableConfig,
            localVariableBody
        )

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as WalletCreationInfo
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
    * Send funds from a wallet
    * Sends funds from a wallet to one or multiple addresses.  --- ## Required Authorization Token This transaction requires an authorization &#x60;token&#x60; which is the result of the &#x60;sha-256&#x60; hash of the following string:        walletId~destination~seed~walletPassphrase    **For example**  Considering the following example values for the token:   - &#x60;walletId&#x60; 9df3f909-088d-4724-b34f-9a587c5ccc15   - &#x60;destination&#x60;     [{\&quot;address\&quot;:\&quot;bc1q5defveu0acrf87m3huwxjq6pqaszdjf3d4ej9y\&quot;,\&quot;amount\&quot;:0.01},{\&quot;address\&quot;:\&quot;bc1qs59a7e23zpjm0znteytrxvj839dlp205e50zch\&quot;,\&quot;amount\&quot;:0.056}]     - &#x60;seed&#x60; 758748394   - &#x60;walletPassphrase&#x60; **Note: this was provided when you created the wallet** OHh6IIININmfmjGGsxlBBft2ch61VncaPscsp295h2ULx9xPY07Jom3d5cBifgoW    The resulting string, previous to hash is::        9df3f909-088d-4724-b34f-9a587c5ccc15~[{\&quot;address\&quot;:\&quot;bc1q5defveu0acrf87m3huwxjq6pqaszdjf3d4ej9y\&quot;,\&quot;amount\&quot;:0.01},{\&quot;address\&quot;:\&quot;bc1qs59a7e23zpjm0znteytrxvj839dlp205e50zch\&quot;,\&quot;amount\&quot;:0.056}]~758748394~OHh6IIININmfmjGGsxlBBft2ch61VncaPscsp295h2ULx9xPY07Jom3d5cBifgoW    Finally after applying &#x60;sha-256&#x60; hash, we obtain the required &#x60;token&#x60;:        804ca9457b0fe3e4d243fe9e39e760ff1f287491ae8e79d015f92f7c6c96d7b1       --- ## Important    * Send requests are commonly queued, optionally you can specify a callback to get your web / app notified as soon as the request has been fully broadcasted to the Network.    * Transaction is limited to &#x60;25&#x60; destination addresses per request      * Tx Hash is provided only through the callback      * Confirmed send requests information is &#x60;DELETED&#x60; after &#x60;3 days&#x60; of being confirmed    --- ## Minimum Send Amounts     * &#x60;Bitcoin&#x60;: 0.0001 BTC   * &#x60;Litecoin&#x60;: 0.001 LTC   * &#x60;Bitcoin Cash&#x60;: 0.001 BCH    --- ## Callback Send requests are commonly queued, optionally you can specify a callback to get your web / app notified as soon as the request has been fully broadcasted to the Network.  The callback sent to your callback url is a **POST** request with the following parameters:       *Example:*      currency:     \&quot;BTC\&quot;     walletId:     \&quot;698fd3f6-5482-4798-8a46-6732af440616\&quot;     requestId:    \&quot;123fd3f6-9078-5790-4f40-6932bf440120\&quot;     timestamp:    1577179288     lastupdate:   1577179388     amount:       \&quot;0.01\&quot;     callback:     \&quot;https://callback-url.com\&quot;     destination:  &#39;[{\&quot;address\&quot;: \&quot;bc1qf6ss0qtdn5q42...\&quot;                   \&quot;amount\&quot;: \&quot;0.01\&quot;}]&#39;     txid:         \&quot;2cdac43e92e65cb428e3ed992bcf61347...\&quot;     status:       0 
    * @param currency Object Currency:   * &#x60;btc&#x60;: Bitcoin   * &#x60;ltc&#x60;: Litecoin   * &#x60;bch&#x60;: Bitcoin Cash  
    * @param walletId Wallet where funds to send are stored 
    * @param destination JSON formatted array with all the destination addres(es) and the amount(s) to send\\ &#x60;[{\&quot;address\&quot;:\&quot;desired-destination-address\&quot;,\&quot;amount\&quot;:X.XXXXXXXX}, ...]&#x60;  
    * @param seed Unique random string generated by your web/app. **IT MUST BE UNIQUE PER TRANSACTION PER WALLET** 
    * @param token SHA-256 hash of the concatenated string (substituting with the proper data):\\ &#x60;walletId~destination~seed~walletPassphrase&#x60;  
    * @param paramCallback Optional callback to notify your web / app as soon as the send request has been fully broadcasted to the Network (optional)
    * @return WalletSendRequest
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun createWalletSendRequest(currency: kotlin.String, walletId: kotlin.String, destination: kotlin.String, seed: kotlin.String, token: kotlin.String, paramCallback: kotlin.String?) : WalletSendRequest {
        val localVariableBody: kotlin.Any? = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, List<kotlin.String>>()
            .apply {
                put("destination", listOf(destination.toString()))
                put("seed", listOf(seed.toString()))
                put("token", listOf(token.toString()))
                if (paramCallback != null) {
                    put("callback", listOf(paramCallback.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        val localVariableConfig = RequestConfig(
            RequestMethod.POST,
            "/{currency}/wallets/{walletId}/send-requests".replace("{"+"currency"+"}", "$currency").replace("{"+"walletId"+"}", "$walletId"),
            query = localVariableQuery,
            headers = localVariableHeaders
        )
        val localVarResponse = request<WalletSendRequest>(
            localVariableConfig,
            localVariableBody
        )

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as WalletSendRequest
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
    * Get Wallet information
    * Gets detailed information from a Wallet
    * @param currency Object Currency:   * &#x60;btc&#x60;: Bitcoin   * &#x60;ltc&#x60;: Litecoin   * &#x60;bch&#x60;: Bitcoin Cash  
    * @param walletId ID of the desired Wallet 
    * @return Wallet
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun getWallet(currency: kotlin.String, walletId: kotlin.String) : Wallet {
        val localVariableBody: kotlin.Any? = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        val localVariableConfig = RequestConfig(
            RequestMethod.GET,
            "/{currency}/wallets/{walletId}".replace("{"+"currency"+"}", "$currency").replace("{"+"walletId"+"}", "$walletId"),
            query = localVariableQuery,
            headers = localVariableHeaders
        )
        val localVarResponse = request<Wallet>(
            localVariableConfig,
            localVariableBody
        )

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as Wallet
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
    * Get last transactions of wallet
    * Gets last 100 transactions of the wallet
    * @param currency Object Currency:   * &#x60;btc&#x60;: Bitcoin   * &#x60;ltc&#x60;: Litecoin   * &#x60;bch&#x60;: Bitcoin Cash  
    * @param walletId ID of the desired Wallet 
    * @return WalletHistory
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun getWalletHistory(currency: kotlin.String, walletId: kotlin.String) : WalletHistory {
        val localVariableBody: kotlin.Any? = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        val localVariableConfig = RequestConfig(
            RequestMethod.GET,
            "/{currency}/wallets/{walletId}/history".replace("{"+"currency"+"}", "$currency").replace("{"+"walletId"+"}", "$walletId"),
            query = localVariableQuery,
            headers = localVariableHeaders
        )
        val localVarResponse = request<WalletHistory>(
            localVariableConfig,
            localVariableBody
        )

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as WalletHistory
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
    * Obtain information of a send request
    * Obtains detailed information about a send request
    * @param currency Object Currency:   * &#x60;btc&#x60;: Bitcoin   * &#x60;ltc&#x60;: Litecoin   * &#x60;bch&#x60;: Bitcoin Cash  
    * @param walletId Wallet where funds to send are stored 
    * @param requestId Send Request ID 
    * @return WalletSendRequest
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun getWalletSendRequest(currency: kotlin.String, walletId: kotlin.String, requestId: kotlin.String) : WalletSendRequest {
        val localVariableBody: kotlin.Any? = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        val localVariableConfig = RequestConfig(
            RequestMethod.GET,
            "/{currency}/wallets/{walletId}/send-requests/{requestId}".replace("{"+"currency"+"}", "$currency").replace("{"+"walletId"+"}", "$walletId").replace("{"+"requestId"+"}", "$requestId"),
            query = localVariableQuery,
            headers = localVariableHeaders
        )
        val localVarResponse = request<WalletSendRequest>(
            localVariableConfig,
            localVariableBody
        )

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as WalletSendRequest
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

}
